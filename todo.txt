:: Research Progress ::
- produced a visual DAG for BoGL specifically, but for a simpler version of BoGL
- produce a general description of a CFG to represent language dependencies (derived from the grammar)
- updated with notes from last meeting
- should be developing this DAG approach for one or more toy languages
    - abstract graph away from JUST BoGL
    - Arithmetic toy language
- Usage dependencies
    - Program can be considered a syntactic rep of a given language, w/ bound names
    - For every name bound in the program, the type of the binding is a language dependency (NT)
        - This falls in line with the Grammar idea, Terminals are dependent on Nonterminals (Ts are bindings, NTs are types, types are eventually bound into a terminal value)
    - For every unique name used, but not bound in the program, this qualifies as a usage dependency
- goal: produce a method for grading program examples with respect to dependencies in language (syntax) and usage (bound names)
    - grading is subjective, but, given a collection of examples (a curriculum) we could practically determine whether or not they are progressing too fast, too slow, or just right (in regards to introduction of novel syntax and names)
(5/3/2020)
- each kind of dependency should be obtained from a general set of principles
    - usage deps simply based on use of defined names (types,vals, funcs)
        - existing analysis
    - language deps come from syntax (language definitions)
        - lang deps are relationships between nonterminals derived in grammar productions
        - lexical primitives (integers, terminals), not defined in the grammar itself
- enrich symbols (provide explanations...context)
    - something of that...

:: May 10th, 2020 ::
- for any rule, LHS must be a symbol as well
- quickly add some code that determines NTs and Ts in our language purely by whether they are present in any LHS or not
  - lower case Ts, upper case NTs on print
- extend Symbol with Def (bind) & Use (call) parts, in addition to what we already have
  - both are akin to Terminal 'T', but allow easier usage dep identification
  - plug this into the arithmetic grammar
  - should allow checking of usage deps now
- Use SymbolType, check email
  - converts them all to NonTerm or Term when doing basic analysis
- plug this into the arithmetic lang
- write a simple version of the Arithmetic Lang using this

:: June 21st, 2020 ::
- hypothesis: Can we use a grammar representation of a language to determine the quality of teaching material
  - write analyzer in Dependencies.hs
  - test for the arithmetic language
  - test for BoGL
> sketch out and formalize the rules for gauging material (NOT generic)
  - one for the context of the arithmetic lang
  - one for the BoGL


Rules for the Arithmetic Language
1. Produce a representation that captures the grammatical structure of the language
  - representation uses symbols that represent distinct syntactic elements in the language (this could use clarification towards the process)
  - NTs are determined as symbols that show up on the LHS of any rule
  - Ts are any symbols that do not show up as the LHS of any rule
2. For a given program, produce an equivalent representation in the grammar produced in step 1
3. For N programs, do the same
4. Compare the...









What makes good teaching material in English?
- Limited use of grammar (nothing fancy)
- Limited length of material (nothing exhausting)
- Restricted scope to something relevant (nothing boring)

What makes bad teaching material in English?
- Using concepts to base learning on that a student doesn't know of (students are unprepared)
- Teaching concepts in an arbitrary fashion (lack of structure)
- Missing concepts that will be needed later on (missing important details)
- Misleading students in terms of what they are expecting (failed expectations)

Thoughts?
- Good examples serve a goal
- Good examples are concise
- Good examples use what a student has learned or already knows
- Good examples teach or reiterate unfamiliar concepts

- Bad examples do not serve a goal
- Bad examples are not concise
- Bad examples do not use what a student already knows
- Bad examples teach or reiterate familiar concepts

As a formalized set of rules
- For a given set of language dependencies (grammar) L, a subset of these that the student understands U, a subset of these that the student does not understand N, and a goal subset the student wishes to learn G.
  - L, U, N, G
- For an example written in this language, deduce the language dependencies present in the example by matching it to the equivalent grammatical representation
- This example is a good example if it
  - uses previous dependencies the student understands (if any)
  - introduces new dependencies the student does not understand that
    - are goals
    - are dependencies of goals
- This example is the 'simplest' example if there is no other way to write a program that introduces the same new dependencies using fewer known dependencies
  - This is highly contingent on whether the student actually understands what they say they do

So, good examples are segments along a structured path, from a given knowledge base (or recently acquired bit(s) of knowledge), such that they allow a student to stretch a little bit further towards a goal.

I am hypothesizing that good examples






- TEST 1 (arithmetic lang)
  - write up 2 simple arithmetic language programs
  - make a guess about the order
  - make an assessment due to our rules...don't just code around
  - see if it supports our reasoning
- TEST 2 (bogl lang)
  - write up 2 BoGL programs that express the same idea
  - make a guess about the order
  - make an assessment according to our rules
  - see if it supports our reasoning
